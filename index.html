<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KNOT: Umwelten im Dialog - Audio Implementation</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #0a0a0a;
            color: #e0e0e0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 40px;
            font-size: 1.1rem;
        }

        .control-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .umwelt-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .umwelt {
            background: #222;
            border-radius: 10px;
            padding: 20px;
            position: relative;
            overflow: hidden;
        }

        .umwelt::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            opacity: 0.8;
        }

        .umwelt-a::before {
            background: linear-gradient(90deg, #667eea, #5a67d8);
        }

        .umwelt-b::before {
            background: linear-gradient(90deg, #764ba2, #8b5cf6);
        }

        .umwelt h3 {
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 1.3rem;
        }

        .data-display {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }

        .data-item {
            background: #2a2a2a;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }

        .data-label {
            color: #888;
            font-size: 0.85rem;
            margin-bottom: 5px;
        }

        .data-value {
            font-size: 1.5rem;
            font-weight: bold;
            font-variant-numeric: tabular-nums;
        }

        .data-value.bpm {
            color: #667eea;
        }

        .data-value.peak {
            color: #764ba2;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
        }

        .device-selectors {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .device-selectors select {
            padding: 8px 12px;
            background: #333;
            color: #fff;
            border: none;
            border-radius: 5px;
        }
        .speaker-selectors {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .speaker-selectors select {
            padding: 8px 12px;
            background: #333;
            color: #fff;
            border: none;
            border-radius: 5px;
        }
        .speaker-selectors label {
            display: flex;
            align-items: center;
            gap: 5px;
        }


        button {
            background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #444;
            cursor: not-allowed;
            box-shadow: none;
        }

        .visualizer {
            background: #1a1a1a;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        canvas {
            width: 100%;
            height: 200px;
            background: #0a0a0a;
            border-radius: 5px;
        }

        .peak-indicator {
            width: 100%;
            height: 20px;
            background: #2a2a2a;
            border-radius: 10px;
            margin-top: 10px;
            position: relative;
            overflow: hidden;
        }

        .peak-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.5), transparent);
            transform: translateX(-100%);
            transition: transform 0.3s ease;
        }

        .peak-flash.active {
            transform: translateX(100%);
        }

        .knot-status {
            text-align: center;
            margin-top: 20px;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 10px;
        }

        .knot-strength {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #444;
            margin: 0 3px;
            transition: all 0.3s ease;
        }

        .knot-strength.active {
            background: linear-gradient(45deg, #667eea, #764ba2);
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
        }

        .parameter-controls {
            margin-top: 30px;
            padding: 20px;
            background: #1a1a1a;
            border-radius: 10px;
        }

        .parameter-group {
            margin-bottom: 20px;
        }

        .parameter-group h4 {
            margin-bottom: 10px;
            color: #888;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
        }

        .slider-label {
            min-width: 150px;
            font-size: 0.9rem;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            background: #333;
            outline: none;
            border-radius: 3px;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 50%;
            cursor: pointer;
        }

        .slider-value {
            min-width: 60px;
            text-align: right;
            font-variant-numeric: tabular-nums;
        }

        .status-message {
            text-align: center;
            padding: 10px;
            margin: 20px 0;
            border-radius: 5px;
            background: #2a2a2a;
            color: #888;
        }

        .status-message.error {
            background: #4a2a2a;
            color: #ff6b6b;
        }

        .status-message.success {
            background: #2a4a2a;
            color: #51cf66;
        }

        /* Canvas for WebGL Visualization */
        #glsl-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>KNOT: Umwelten im Dialog</h1>
        <p class="subtitle">二つの環世界が織りなす音響的対話</p>

        <div class="controls">
            <button id="startBtn">Start Audio</button>
            <button id="stopBtn" disabled>Stop Audio</button>
            <button id="testA" disabled>Test Peak A</button>
            <button id="testB" disabled>Test Peak B</button>
            <label style="display:flex;align-items:center;gap:5px;">
                <input type="checkbox" id="micMonitorToggle">Monitor Mics
            </label>
        </div>

        <div class="device-selectors">
            <label>Mic A:
                <select id="micSelectA"></select>
            </label>
            <label>Mic B:
                <select id="micSelectB"></select>
            </label>
        </div>
        <div class="speaker-selectors">
            <label>Speaker 1:
                <select class="speakerSelect" id="speakerSelect1"></select>
                <input type="checkbox" class="vibrationToggle" data-index="0">Vibration
            </label>
            <label>Speaker 2:
                <select class="speakerSelect" id="speakerSelect2"></select>
                <input type="checkbox" class="vibrationToggle" data-index="1">Vibration
            </label>
            <label>Speaker 3:
                <select class="speakerSelect" id="speakerSelect3"></select>
                <input type="checkbox" class="vibrationToggle" data-index="2">Vibration
            </label>
            <label>Speaker 4:
                <select class="speakerSelect" id="speakerSelect4"></select>
                <input type="checkbox" class="vibrationToggle" data-index="3">Vibration
            </label>
            <label>Speaker 5:
                <select class="speakerSelect" id="speakerSelect5"></select>
                <input type="checkbox" class="vibrationToggle" data-index="4">Vibration
            </label>
            <label>Speaker 6:
                <select class="speakerSelect" id="speakerSelect6"></select>
                <input type="checkbox" class="vibrationToggle" data-index="5">Vibration
            </label>
        </div>

        <div id="statusMessage" class="status-message"></div>

        <div class="control-panel">
            <div style="text-align: center; margin-bottom: 20px; padding: 15px; background: #2a2a2a; border-radius: 10px;">
                <p style="margin: 0; color: #888;">
                    <strong>Note:</strong> This system uses your microphone to detect heartbeats. 
                    For best results, place the microphone near your chest or use a stethoscope microphone.
                    If microphone access is denied, the system will run in test mode.
                </p>
            </div>
            <div class="umwelt-container">
                <div class="umwelt umwelt-a">
                    <h3>Umwelt A (左)</h3>
                    <div class="data-display">
                        <div class="data-item">
                            <div class="data-label">BPM</div>
                            <div class="data-value bpm" id="bpmA">--</div>
                        </div>
                        <div class="data-item">
                            <div class="data-label">Peak</div>
                            <div class="data-value peak" id="peakA">0.00</div>
                        </div>
                    </div>
                    <div class="peak-indicator">
                        <div class="peak-flash" id="peakFlashA"></div>
                    </div>
                    <canvas id="waveformA"></canvas>
                </div>

                <div class="umwelt umwelt-b">
                    <h3>Umwelt B (右)</h3>
                    <div class="data-display">
                        <div class="data-item">
                            <div class="data-label">BPM</div>
                            <div class="data-value bpm" id="bpmB">--</div>
                        </div>
                        <div class="data-item">
                            <div class="data-label">Peak</div>
                            <div class="data-value peak" id="peakB">0.00</div>
                        </div>
                    </div>
                    <div class="peak-indicator">
                        <div class="peak-flash" id="peakFlashB"></div>
                    </div>
                    <canvas id="waveformB"></canvas>
                </div>
            </div>

            <div class="knot-status">
                <h3>KNOT Status</h3>
                <div>
                    <span class="knot-strength" id="knot1"></span>
                    <span class="knot-strength" id="knot2"></span>
                    <span class="knot-strength" id="knot3"></span>
                    <span class="knot-strength" id="knot4"></span>
                    <span class="knot-strength" id="knot5"></span>
                </div>
                <p id="knotDescription">Waiting for interaction...</p>
            </div>
        </div>

        <div class="parameter-controls">
            <h3>Audio Parameters</h3>
            
            <div class="parameter-group">
                <h4>Input Processing</h4>
                <div class="slider-container">
                    <span class="slider-label">Lowpass Filter</span>
                    <input type="range" id="lowpassFreq" min="50" max="500" value="150">
                    <span class="slider-value" id="lowpassFreqValue">150 Hz</span>
                </div>
                <div class="slider-container">
                    <span class="slider-label">Peak Threshold</span>
                    <input type="range" id="peakThreshold" min="0.1" max="1" step="0.1" value="0.7">
                    <span class="slider-value" id="peakThresholdValue">0.7</span>
                </div>
                <div class="slider-container">
                    <span class="slider-label">Mic Monitor Gain</span>
                    <input type="range" id="micMonitorGain" min="0" max="40" step="1" value="28">
                    <span class="slider-value" id="micMonitorGainValue">28 dB</span>
                </div>
                <div class="slider-container">
                    <span class="slider-label">Mic Filter</span>
                    <input type="range" id="micFilterFreq" min="50" max="500" value="100">
                    <span class="slider-value" id="micFilterFreqValue">100 Hz</span>
                </div>
            </div>

            <div class="parameter-group">
                <h4>Sound Generation</h4>
                <div class="slider-container">
                    <span class="slider-label">Trigger A Frequency</span>
                    <input type="range" id="triggerAFreq" min="200" max="1000" value="660">
                    <span class="slider-value" id="triggerAFreqValue">660 Hz</span>
                </div>
                <div class="slider-container">
                    <span class="slider-label">Drone A Frequency</span>
                    <input type="range" id="droneAFreq" min="50" max="200" value="110">
                    <span class="slider-value" id="droneAFreqValue">110 Hz</span>
                </div>
                <div class="slider-container">
                    <span class="slider-label">Drone B Frequency</span>
                    <input type="range" id="droneBFreq" min="50" max="200" value="130">
                    <span class="slider-value" id="droneBFreqValue">130 Hz</span>
                </div>
            </div>

            <div class="parameter-group">
                <h4>KNOT Effect</h4>
                <div class="slider-container">
                    <span class="slider-label">Delay Base Time</span>
                    <input type="range" id="delayBase" min="0.1" max="1" step="0.1" value="0.4">
                    <span class="slider-value" id="delayBaseValue">0.4 s</span>
                </div>
                <div class="slider-container">
                    <span class="slider-label">Modulation Amount</span>
                    <input type="range" id="modAmount" min="0" max="0.5" step="0.05" value="0.3">
                    <span class="slider-value" id="modAmountValue">0.3 s</span>
                </div>
                <div class="slider-container">
                    <span class="slider-label">Feedback</span>
                    <input type="range" id="feedback" min="0" max="0.8" step="0.1" value="0.4">
                    <span class="slider-value" id="feedbackValue">0.4</span>
                </div>
            </div>

            <div class="parameter-group">
                <h4>Mix Levels</h4>
                <div class="slider-container">
                    <span class="slider-label">Pre-KNOT Gain</span>
                    <input type="range" id="preKnotGain" min="0" max="1" step="0.1" value="0.7">
                    <span class="slider-value" id="preKnotGainValue">0.7</span>
                </div>
                <div class="slider-container">
                    <span class="slider-label">KNOT FX Gain</span>
                    <input type="range" id="knotFxGain" min="0" max="1" step="0.1" value="0.3">
                    <span class="slider-value" id="knotFxGainValue">0.3</span>
                </div>
            </div>
        </div>
    </div>

    <!-- WebGL Visualization -->
    <canvas id="glsl-canvas"></canvas>

    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        /*
         * Title: "Aural Viscera" (Final Ver.)
         * Author: Gemini
         * Features: Seamless blending and a synchronization algorithm.
         */
        precision highp float;

        uniform float time;
        uniform vec2 resolution;
        uniform float heart_a_peak;
        uniform float heart_a_age;
        uniform float heart_b_peak;
        uniform float heart_b_age;

        // --- ユーティリティ関数 ---
        mat2 rotate(float a) {
            float s = sin(a); float c = cos(a);
            return mat2(c, -s, s, c);
        }

        float rand(vec2 n) {
            return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
        }

        float snoise(vec2 p) {
            vec2 ip = floor(p);
            vec2 fp = fract(p);
            fp = fp * fp * (3.0 - 2.0 * fp);
            float a = rand(ip);
            float b = rand(ip + vec2(1.0, 0.0));
            float c = rand(ip + vec2(0.0, 1.0));
            float d = rand(ip + vec2(1.0, 1.0));
            return mix(mix(a, b, fp.x), mix(c, d, fp.x), fp.y);
        }

        float fbm(vec2 p) {
            float v = 0.0; float a = 0.5;
            mat2 rot = rotate(time * 0.05);
            for (int i = 0; i < 6; i++) {
                v += a * snoise(p);
                p = rot * p * 2.1;
                a *= 0.5;
            }
            return v;
        }

        // --- メイン処理 ---
        void main() {
            vec2 uv = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);

            float dist = length(uv);
            float orb_mask = smoothstep(1.0, 0.95, dist);
            if (orb_mask < 0.01) discard;

            float mix_factor = smoothstep(-0.4, 0.4, uv.x);

            // Player A
            vec3 color_a = vec3(0.1, 0.7, 1.0);
            float pulse_wave_a = sin(dist * 25.0 - heart_a_age * 8.0) * 0.05 * heart_a_peak;
            float brightness_a = 0.3 + heart_a_peak * 0.7;

            // Player B
            vec3 color_b = vec3(1.0, 0.1, 0.5);
            float pulse_wave_b = sin(dist * 25.0 - heart_b_age * 8.0) * 0.05 * heart_b_peak;
            float brightness_b = 0.3 + heart_b_peak * 0.7;

            // 融合
            vec3 mixed_base_color = mix(color_a, color_b, mix_factor);
            float mixed_pulse_wave = mix(pulse_wave_a, pulse_wave_b, mix_factor);
            float mixed_brightness = mix(brightness_a, brightness_b, mix_factor);

            // 描画
            vec2 noisy_uv = uv + uv * mixed_pulse_wave;
            float noisy_pattern = fbm(noisy_uv * 2.5);
            vec3 hemisphere_color = mixed_base_color * (0.6 + noisy_pattern * 0.4) * mixed_brightness;

            // 大気と光の散乱
            float cloud_fbm = fbm(uv * 1.5 + time * 0.02);
            float atmosphere_mask = cloud_fbm * 0.4 + 0.6;
            float scattering_fbm = fbm(uv * 3.0 - time * 0.03);
            float radial_glow = pow(1.0 - dist, 4.0);
            float light_scattering = radial_glow * scattering_fbm * 0.4;
            hemisphere_color += mixed_base_color * light_scattering * (0.5 + mixed_brightness);

            vec3 final_color = hemisphere_color * atmosphere_mask;

            // 共鳴
            float resonance_strength = heart_a_peak * heart_b_peak * 1.5;
            if (resonance_strength > 0.0) {
                float rift_fbm = fbm(uv * vec2(0.4, 3.0) + vec2(0.0, time * -0.4));
                float rift_mask = smoothstep(0.15, 0.0, abs(uv.x)) * pow(rift_fbm, 2.0);
                vec3 resonance_color = vec3(1.0, 1.0, 0.85) * rift_mask * resonance_strength;
                final_color += resonance_color;
            }

            // 星
            float star_field = pow(fbm(uv * 4.0), 25.0);
            final_color += vec3(star_field) * 0.3;

            gl_FragColor = vec4(final_color * orb_mask, 1.0);
        }
    </script>

    <script>
        // --- WebGL初期化と描画ループのJavaScript ---
        const canvas = document.getElementById('glsl-canvas');
        const gl = canvas.getContext('webgl', { antialias: false });

        if (!gl) { alert('WebGL is not supported by your browser.'); }

        const vertexShaderSource = document.getElementById('vertex-shader').textContent;
        const fragmentShaderSource = document.getElementById('fragment-shader').textContent;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type); gl.shaderSource(shader, source); gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { console.error('Shader compile error: ' + gl.getShaderInfoLog(shader)); gl.deleteShader(shader); return null; }
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) { console.error('Program link error: ' + gl.getProgramInfoLog(program)); }

        const uniformLocations = {
            time: gl.getUniformLocation(program, 'time'),
            resolution: gl.getUniformLocation(program, 'resolution'),
            heart_a_peak: gl.getUniformLocation(program, 'heart_a_peak'),
            heart_a_age: gl.getUniformLocation(program, 'heart_a_age'),
            heart_b_peak: gl.getUniformLocation(program, 'heart_b_peak'),
            heart_b_age: gl.getUniformLocation(program, 'heart_b_age')
        };
        const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        // Heartbeat visuals for Umwelt A and B
        const heart_a = { peak: 0, age: 0, bpm: 72 };
        const heart_b = { peak: 0, age: 0, bpm: 78 };

        let last_a_beat = 0;
        let last_b_beat = 0;

        let syncState = 'ASYNC';
        let timeInSync = 0.0;
        const SYNC_THRESHOLD_BPM = 2.0;
        const SYNC_ACTIVATE_TIME = 3.0;
        let shared_bpm = 75;
        let last_shared_beat = 0;

        let lastFrameTime = 0;
        function render(time) {
            const currentTime = time * 0.001;
            const dt = currentTime - lastFrameTime;
            lastFrameTime = currentTime;

            // --- 心拍の状態を更新 (マイク入力反映) ---
            const dataA = window.audioAnalysisData?.A || {};
            const dataB = window.audioAnalysisData?.B || {};

            if (dataA.bpm) heart_a.bpm = dataA.bpm;
            if (dataB.bpm) heart_b.bpm = dataB.bpm;

            const peakA = (dataA.lastPeakTime || 0) / 1000;
            const peakB = (dataB.lastPeakTime || 0) / 1000;

            if (peakA > last_a_beat) {
                heart_a.peak = 1.0;
                heart_a.age = 0.0;
                last_a_beat = peakA;
            }

            if (peakB > last_b_beat) {
                heart_b.peak = 1.0;
                heart_b.age = 0.0;
                last_b_beat = peakB;
            }

            const bpm_diff = Math.abs(heart_a.bpm - heart_b.bpm);
            if (bpm_diff < SYNC_THRESHOLD_BPM) {
                timeInSync += dt;
            } else {
                timeInSync = 0.0;
                syncState = 'ASYNC';
            }

            if (timeInSync > SYNC_ACTIVATE_TIME) {
                syncState = 'SYNCING';
            }

            if (syncState === 'SYNCING') {
                shared_bpm = (heart_a.bpm + heart_b.bpm) / 2.0;
                if (currentTime - last_shared_beat > 60.0 / shared_bpm) {
                    heart_a.peak = 1.0; heart_b.peak = 1.0;
                    heart_a.age = 0.0;  heart_b.age = 0.0;
                    last_shared_beat = currentTime;
                }
            }

            heart_a.age += dt;
            heart_b.age += dt;
            heart_a.peak = Math.max(0, heart_a.peak - dt * 1.5);
            heart_b.peak = Math.max(0, heart_b.peak - dt * 1.5);

            // WebGL描画
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.useProgram(program);

            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

            gl.uniform1f(uniformLocations.time, currentTime);
            gl.uniform2f(uniformLocations.resolution, gl.canvas.width, gl.canvas.height);
            gl.uniform1f(uniformLocations.heart_a_peak, heart_a.peak);
            gl.uniform1f(uniformLocations.heart_a_age, heart_a.age);
            gl.uniform1f(uniformLocations.heart_b_peak, heart_b.peak);
            gl.uniform1f(uniformLocations.heart_b_age, heart_b.age);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>

    <script>
        // Global audio analysis data for visual module integration
        window.audioAnalysisData = {
            A: {
                bpm: 0,
                peak: 0,
                isNewPeak: false,
                lastPeakTime: 0
            },
            B: {
                bpm: 0,
                peak: 0,
                isNewPeak: false,
                lastPeakTime: 0
            }
        };

        // Audio context and nodes
        let audioContext;
        let isRunning = false;
        let micStreamA = null;
        let micStreamB = null;

        let selectedDeviceIdA = null;
        let selectedDeviceIdB = null;

        // Audio nodes for Umwelt A
        let sourceA, analyserA, filterA, gainA, pannerA;
        let droneOscA, droneFilterA, droneGainA;
        let triggerOscA, triggerGainA;
        let micFilterA, micGainA;

        // Audio nodes for Umwelt B
        let sourceB, analyserB, filterB, gainB, pannerB;
        let droneOscB, droneFilterB, droneGainB;
        let triggerOscB, triggerGainB;
        let micFilterB, micGainB;

        let channelSplitter;

        // KNOT effect nodes
        let delayA, delayB, delayGainA, delayGainB;
        let feedbackGainA, feedbackGainB;
        let masterGain, fxGain;
        let selectedSpeakerIds = Array(6).fill("");
        let vibrationFlags = Array(6).fill(false);
        let outputNodes = [];
        let outputAudios = [];


        // Test mode flag
        let isTestMode = false;

        // Microphone monitoring
        function dBToAmp(db) {
            return Math.pow(10, db / 20);
        }
        let micMonitorEnabled = false;

        // Parameters
        const params = {
            INPUT_LOWPASS_FREQ: 150,
            PEAK_THRESHOLD: 0.7,
            BPM_MOVING_AVG_SIZE: 5,
            PAN_A: -1.0,
            PAN_B: 1.0,
            TRIGGER_A_FREQ: 660,
            DRONE_A_BASE_FREQ: 110,
            DRONE_B_BASE_FREQ: 130,
            MIC_MONITOR_GAIN_DB: 28,
            MIC_FILTER_FREQ: 100,
            KNOT_DELAY_BASE_TIME: 0.4,
            KNOT_DELAY_MOD_AMOUNT: 0.3,
            KNOT_DELAY_FEEDBACK: 0.4,
            PRE_KNOT_GAIN: 0.7,
            KNOT_FX_GAIN: 0.3
        };


        async function populateDeviceSelectors() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(d => d.kind === 'audioinput');
                const audioOutputs = devices.filter(d => d.kind === 'audiooutput');

                const selectA = document.getElementById('micSelectA');
                const selectB = document.getElementById('micSelectB');
                const speakerSelects = document.querySelectorAll('.speakerSelect');
                const vibrationToggles = document.querySelectorAll('.vibrationToggle');

                selectA.innerHTML = '';
                selectB.innerHTML = '';
                speakerSelects.forEach(s => s.innerHTML = '');

                audioInputs.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Microphone ${index + 1}`;
                    selectA.appendChild(option);

                    const optionB = option.cloneNode(true);
                    selectB.appendChild(optionB);
                });

                if (audioInputs.length > 0) {
                    selectedDeviceIdA = selectA.value;
                    selectedDeviceIdB = audioInputs[1] ? selectB.options[1].value : selectA.value;
                    selectB.value = selectedDeviceIdB;
                }

                speakerSelects.forEach((select, idx) => {
                    const defOpt = document.createElement('option');
                    defOpt.value = '';
                    defOpt.textContent = 'Default';
                    select.appendChild(defOpt);
                    audioOutputs.forEach((device, i) => {
                        const opt = document.createElement('option');
                        opt.value = device.deviceId;
                        opt.textContent = device.label || `Speaker ${i + 1}`;
                        select.appendChild(opt);
                    });
                    select.value = selectedSpeakerIds[idx] || '';
                    select.addEventListener('change', e => {
                        selectedSpeakerIds[idx] = e.target.value;
                        if (audioContext) updateSpeakerOutputs();
                    });
                });

                vibrationToggles.forEach((toggle, idx) => {
                    toggle.checked = vibrationFlags[idx];
                    toggle.addEventListener('change', e => {
                        vibrationFlags[idx] = e.target.checked;
                        if (audioContext) updateSpeakerOutputs();
                    });
                });

                selectA.addEventListener('change', e => {
                    selectedDeviceIdA = e.target.value;
                });
                selectB.addEventListener('change', e => {
                    selectedDeviceIdB = e.target.value;
                });
            } catch (err) {
                console.error('Failed to enumerate devices', err);
            }
        }
        // Heartbeat detector class
        function updateSpeakerOutputs() {
            if (!audioContext || !masterGain || !fxGain) return;

            try {
                masterGain.disconnect();
                fxGain.disconnect();
            } catch (e) {}

            outputNodes.forEach(node => {
                try {
                    masterGain.disconnect(node);
                    fxGain.disconnect(node);
                    node.disconnect();
                } catch (e) {}
            });
            outputNodes = [];
            outputAudios.forEach(el => el.remove());
            outputAudios = [];

            const ids = selectedSpeakerIds.filter(id => id);
            if (ids.length === 0) {
                masterGain.connect(audioContext.destination);
                fxGain.connect(audioContext.destination);
                return;
            }

            selectedSpeakerIds.forEach((id, idx) => {
                if (!id) return;
                const dest = audioContext.createMediaStreamDestination();
                let connectNode = dest;
                if (vibrationFlags[idx]) {
                    const filter = audioContext.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 150;
                    masterGain.connect(filter);
                    fxGain.connect(filter);
                    filter.connect(dest);
                    connectNode = filter;
                } else {
                    masterGain.connect(dest);
                    fxGain.connect(dest);
                }
                const audioEl = new Audio();
                audioEl.srcObject = dest.stream;
                if (audioEl.setSinkId) {
                    audioEl.setSinkId(id).catch(err => console.error('setSinkId error', err));
                }
                audioEl.play().catch(err => console.error('audio play error', err));
                outputNodes.push(connectNode);
                outputAudios.push(audioEl);
            });
        }
        class HeartbeatDetector {
            constructor(threshold = 0.7, cooldownMs = 300) {
                this.threshold = threshold;
                this.cooldownTime = cooldownMs;
                this.lastPeakTime = 0;
                this.peakHistory = [];
                this.bpm = 0;
            }

            detectPeak(amplitude, currentTime) {
                const timeSinceLastPeak = currentTime - this.lastPeakTime;
                
                if (amplitude > this.threshold && timeSinceLastPeak > this.cooldownTime) {
                    this.lastPeakTime = currentTime;
                    this.peakHistory.push(currentTime);
                    
                    // Calculate BPM from recent peaks
                    if (this.peakHistory.length > params.BPM_MOVING_AVG_SIZE) {
                        this.peakHistory.shift();
                        const intervals = [];
                        for (let i = 1; i < this.peakHistory.length; i++) {
                            intervals.push(this.peakHistory[i] - this.peakHistory[i-1]);
                        }
                        const avgInterval = intervals.reduce((a, b) => a + b) / intervals.length;
                        this.bpm = 60000 / avgInterval;
                    }
                    
                    return { isNewPeak: true, bpm: this.bpm, peak: amplitude };
                }
                
                return { isNewPeak: false, bpm: this.bpm, peak: 0 };
            }

            reset() {
                this.lastPeakTime = 0;
                this.peakHistory = [];
                this.bpm = 0;
            }
        }

        const detectorA = new HeartbeatDetector();
        const detectorB = new HeartbeatDetector();

        // Initialize audio system
        async function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();

                await populateDeviceSelectors();
                
                // Create master gain and fx gain
                masterGain = audioContext.createGain();
                masterGain.gain.value = params.PRE_KNOT_GAIN;
                
                fxGain = audioContext.createGain();
                fxGain.gain.value = params.KNOT_FX_GAIN;
                
                masterGain.connect(audioContext.destination);
                fxGain.connect(audioContext.destination);

                // Initialize Umwelt A
                await initUmweltA();
                
                // Initialize Umwelt B
                await initUmweltB();
                
                // Initialize KNOT effects
                initKnotEffects();
                updateSpeakerOutputs();
                
                // Start animation loop
                animate();
                
                isRunning = true;
                updateStatus('Audio system initialized', 'success');
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('testA').disabled = false;
                document.getElementById('testB').disabled = false;
                
            } catch (error) {
                console.error('Error initializing audio:', error);
                updateStatus('Error: ' + error.message, 'error');
            }
        }

        async function initUmweltA() {
            // Create analyser
            analyserA = audioContext.createAnalyser();
            analyserA.fftSize = 2048;
            
            // Create filter
            filterA = audioContext.createBiquadFilter();
            filterA.type = 'lowpass';
            filterA.frequency.value = params.INPUT_LOWPASS_FREQ;
            filterA.Q.value = 1;
            
            // Create gain
            gainA = audioContext.createGain();
            gainA.gain.value = 0.3;
            
            // Create panner
            pannerA = audioContext.createStereoPanner();
            pannerA.pan.value = params.PAN_A;
            
            // Create drone oscillator
            droneOscA = audioContext.createOscillator();
            droneOscA.type = 'sawtooth';
            droneOscA.frequency.value = params.DRONE_A_BASE_FREQ;
            
            droneFilterA = audioContext.createBiquadFilter();
            droneFilterA.type = 'lowpass';
            droneFilterA.frequency.value = 200;
            
            droneGainA = audioContext.createGain();
            droneGainA.gain.value = 0.1;
            
            // Connect drone chain
            droneOscA.connect(droneFilterA);
            droneFilterA.connect(droneGainA);
            droneGainA.connect(pannerA);
            
            // Connect main chain
            filterA.connect(analyserA);
            filterA.connect(gainA);
            gainA.connect(pannerA);
            pannerA.connect(masterGain);
            
            // Start drone
            droneOscA.start();
            
            // Try to get microphone input
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        deviceId: selectedDeviceIdA ? { exact: selectedDeviceIdA } : undefined,
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });
                micStreamA = stream;
                sourceA = audioContext.createMediaStreamSource(stream);
                sourceA.connect(filterA);

                micFilterA = audioContext.createBiquadFilter();
                micFilterA.type = 'lowpass';
                micFilterA.frequency.value = params.MIC_FILTER_FREQ;
                micGainA = audioContext.createGain();
                micGainA.gain.value = micMonitorEnabled ? dBToAmp(params.MIC_MONITOR_GAIN_DB) : 0;
                sourceA.connect(micFilterA);
                micFilterA.connect(micGainA);
                micGainA.connect(pannerA);
                updateStatus('Microphone A connected', 'success');
                isTestMode = false;
            } catch (error) {
                console.warn('Microphone access denied, using test oscillator:', error);
                updateStatus('Using test mode (microphone access denied)', 'error');
                isTestMode = true;
                
                // Fallback to test oscillator
                const testOsc = audioContext.createOscillator();
                testOsc.frequency.value = 1.2; // Simulate 72 BPM heartbeat
                const testGain = audioContext.createGain();
                testGain.gain.value = 0;
                testOsc.connect(testGain);
                testGain.connect(filterA);
                testOsc.start();
                sourceA = testGain;
            }
        }

        async function initUmweltB() {
            // Create analyser
            analyserB = audioContext.createAnalyser();
            analyserB.fftSize = 2048;
            
            // Create filter
            filterB = audioContext.createBiquadFilter();
            filterB.type = 'lowpass';
            filterB.frequency.value = params.INPUT_LOWPASS_FREQ;
            filterB.Q.value = 1;
            
            // Create gain
            gainB = audioContext.createGain();
            gainB.gain.value = 0.3;
            
            // Create panner
            pannerB = audioContext.createStereoPanner();
            pannerB.pan.value = params.PAN_B;
            
            // Create drone oscillator
            droneOscB = audioContext.createOscillator();
            droneOscB.type = 'triangle';
            droneOscB.frequency.value = params.DRONE_B_BASE_FREQ;
            
            droneFilterB = audioContext.createBiquadFilter();
            droneFilterB.type = 'lowpass';
            droneFilterB.frequency.value = 250;
            
            droneGainB = audioContext.createGain();
            droneGainB.gain.value = 0.1;
            
            // Connect drone chain
            droneOscB.connect(droneFilterB);
            droneFilterB.connect(droneGainB);
            droneGainB.connect(pannerB);
            
            // Connect main chain
            filterB.connect(analyserB);
            filterB.connect(gainB);
            gainB.connect(pannerB);
            pannerB.connect(masterGain);
            
            // Start drone
            droneOscB.start();
            
            // Attempt to use a second microphone if available
            try {
                let stream;
                if (selectedDeviceIdB === selectedDeviceIdA && micStreamA) {
                    stream = micStreamA;

                    if (!channelSplitter) {
                        channelSplitter = audioContext.createChannelSplitter(2);
                        sourceA.disconnect();
                        sourceA.connect(channelSplitter);
                        channelSplitter.connect(filterA, 0);
                        if (micFilterA) channelSplitter.connect(micFilterA, 0);
                    }

                    micFilterB = audioContext.createBiquadFilter();
                    micFilterB.type = 'lowpass';
                    micFilterB.frequency.value = params.MIC_FILTER_FREQ;
                    micGainB = audioContext.createGain();
                    micGainB.gain.value = micMonitorEnabled ? dBToAmp(params.MIC_MONITOR_GAIN_DB) : 0;
                    channelSplitter.connect(micFilterB, 1);
                    micFilterB.connect(micGainB);
                    micGainB.connect(pannerB);

                    channelSplitter.connect(filterB, 1);
                    sourceB = channelSplitter;
                } else {
                    stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            deviceId: selectedDeviceIdB ? { exact: selectedDeviceIdB } : undefined,
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    });
                    micStreamB = stream;
                    sourceB = audioContext.createMediaStreamSource(stream);
                    sourceB.connect(filterB);

                    micFilterB = audioContext.createBiquadFilter();
                    micFilterB.type = 'lowpass';
                    micFilterB.frequency.value = params.MIC_FILTER_FREQ;
                    micGainB = audioContext.createGain();
                    micGainB.gain.value = micMonitorEnabled ? dBToAmp(params.MIC_MONITOR_GAIN_DB) : 0;
                    sourceB.connect(micFilterB);
                    micFilterB.connect(micGainB);
                    micGainB.connect(pannerB);
                }
            } catch (error) {
                const testOsc = audioContext.createOscillator();
                testOsc.frequency.value = 1.3;
                const testGain = audioContext.createGain();
                testGain.gain.value = 0;
                testOsc.connect(testGain);
                testGain.connect(filterB);
                testOsc.start();
                sourceB = testGain;
            }
        }

        function initKnotEffects() {
            // Create delay nodes
            delayA = audioContext.createDelay(2);
            delayA.delayTime.value = params.KNOT_DELAY_BASE_TIME;
            
            delayB = audioContext.createDelay(2);
            delayB.delayTime.value = params.KNOT_DELAY_BASE_TIME;
            
            // Create feedback loops
            feedbackGainA = audioContext.createGain();
            feedbackGainA.gain.value = params.KNOT_DELAY_FEEDBACK;
            
            feedbackGainB = audioContext.createGain();
            feedbackGainB.gain.value = params.KNOT_DELAY_FEEDBACK;
            
            delayGainA = audioContext.createGain();
            delayGainA.gain.value = 0.5;
            
            delayGainB = audioContext.createGain();
            delayGainB.gain.value = 0.5;
            
            // Connect KNOT effects
            pannerA.connect(delayA);
            delayA.connect(feedbackGainA);
            feedbackGainA.connect(delayA);
            delayA.connect(delayGainA);
            delayGainA.connect(fxGain);
            
            pannerB.connect(delayB);
            delayB.connect(feedbackGainB);
            feedbackGainB.connect(delayB);
            delayB.connect(delayGainB);
            delayGainB.connect(fxGain);
        }

        function triggerSoundA() {
            if (!audioContext) return;
            
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc.type = 'sine';
            osc.frequency.value = params.TRIGGER_A_FREQ;
            
            gain.gain.setValueAtTime(0, audioContext.currentTime);
            gain.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
            
            osc.connect(gain);
            gain.connect(pannerA);
            
            osc.start();
            osc.stop(audioContext.currentTime + 0.3);
        }

        function triggerSoundB() {
            if (!audioContext) return;
            
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc.type = 'triangle';
            osc.frequency.value = params.TRIGGER_A_FREQ * 0.75;
            
            gain.gain.setValueAtTime(0, audioContext.currentTime);
            gain.gain.linearRampToValueAtTime(0.25, audioContext.currentTime + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.4);
            
            osc.connect(gain);
            gain.connect(pannerB);
            
            osc.start();
            osc.stop(audioContext.currentTime + 0.4);
        }

        function analyzeAudio() {
            if (!audioContext || !isRunning) return;
            
            const bufferLength = analyserA.frequencyBinCount;
            const dataArrayA = new Uint8Array(bufferLength);
            const dataArrayB = new Uint8Array(bufferLength);
            
            analyserA.getByteTimeDomainData(dataArrayA);
            analyserB.getByteTimeDomainData(dataArrayB);
            
            // Calculate amplitudes
            let maxA = 0, maxB = 0;
            for (let i = 0; i < bufferLength; i++) {
                const valA = Math.abs(dataArrayA[i] - 128) / 128;
                const valB = Math.abs(dataArrayB[i] - 128) / 128;
                if (valA > maxA) maxA = valA;
                if (valB > maxB) maxB = valB;
            }
            
            // Detect peaks
            const currentTime = Date.now();
            const resultA = detectorA.detectPeak(maxA, currentTime);
            const resultB = detectorB.detectPeak(maxB, currentTime);
            
            // Update global data
            window.audioAnalysisData.A = {
                bpm: resultA.bpm,
                peak: maxA,
                isNewPeak: resultA.isNewPeak,
                lastPeakTime: resultA.isNewPeak ? currentTime : window.audioAnalysisData.A.lastPeakTime
            };
            
            window.audioAnalysisData.B = {
                bpm: resultB.bpm,
                peak: maxB,
                isNewPeak: resultB.isNewPeak,
                lastPeakTime: resultB.isNewPeak ? currentTime : window.audioAnalysisData.B.lastPeakTime
            };
            
            // Trigger sounds on peaks
            if (resultA.isNewPeak) {
                triggerSoundA();
                flashPeak('A');
            }
            
            if (resultB.isNewPeak) {
                triggerSoundB();
                flashPeak('B');
            }
            
            // Update cross-modulation
            updateKnotModulation();
            
            // Update UI
            updateUI();
            
            // Draw waveforms
            drawWaveform('A', dataArrayA);
            drawWaveform('B', dataArrayB);
        }

        function updateKnotModulation() {
            if (!audioContext || !delayA || !delayB) return;
            
            const dataA = window.audioAnalysisData.A;
            const dataB = window.audioAnalysisData.B;
            
            // B modulates A's delay
            const modAmountA = dataB.peak * params.KNOT_DELAY_MOD_AMOUNT;
            const newDelayA = params.KNOT_DELAY_BASE_TIME + modAmountA;
            delayA.delayTime.linearRampToValueAtTime(newDelayA, audioContext.currentTime + 0.1);
            
            // A modulates B's delay
            const modAmountB = dataA.peak * params.KNOT_DELAY_MOD_AMOUNT;
            const newDelayB = params.KNOT_DELAY_BASE_TIME + modAmountB;
            delayB.delayTime.linearRampToValueAtTime(newDelayB, audioContext.currentTime + 0.1);
            
            // Modulate drone filters based on BPM stability
            if (dataA.bpm > 0) {
                const filterFreqA = 200 + (dataA.bpm - 60) * 2;
                droneFilterA.frequency.linearRampToValueAtTime(filterFreqA, audioContext.currentTime + 0.5);
            }
            
            if (dataB.bpm > 0) {
                const filterFreqB = 250 + (dataB.bpm - 60) * 2.5;
                droneFilterB.frequency.linearRampToValueAtTime(filterFreqB, audioContext.currentTime + 0.5);
            }
        }

        function updateUI() {
            const dataA = window.audioAnalysisData.A;
            const dataB = window.audioAnalysisData.B;
            
            // Update BPM displays
            document.getElementById('bpmA').textContent = dataA.bpm > 0 ? dataA.bpm.toFixed(1) : '--';
            document.getElementById('bpmB').textContent = dataB.bpm > 0 ? dataB.bpm.toFixed(1) : '--';
            
            // Update peak displays
            document.getElementById('peakA').textContent = dataA.peak.toFixed(2);
            document.getElementById('peakB').textContent = dataB.peak.toFixed(2);
            
            // Update KNOT visualization
            updateKnotVisualization(dataA.peak, dataB.peak);
        }

        function updateKnotVisualization(peakA, peakB) {
            const interaction = (peakA + peakB) / 2;
            const lights = 5;
            const activeLight = Math.floor(interaction * lights);
            
            for (let i = 1; i <= lights; i++) {
                const element = document.getElementById(`knot${i}`);
                if (i <= activeLight) {
                    element.classList.add('active');
                } else {
                    element.classList.remove('active');
                }
            }
            
            // Update description
            const desc = document.getElementById('knotDescription');
            if (interaction < 0.2) {
                desc.textContent = 'Minimal interaction - separate worlds';
            } else if (interaction < 0.4) {
                desc.textContent = 'Gentle influence emerging';
            } else if (interaction < 0.6) {
                desc.textContent = 'Active dialogue in progress';
            } else if (interaction < 0.8) {
                desc.textContent = 'Strong interconnection forming';
            } else {
                desc.textContent = 'Intense entanglement - complex KNOT';
            }
        }

        function flashPeak(umwelt) {
            const flash = document.getElementById(`peakFlash${umwelt}`);
            flash.classList.add('active');
            setTimeout(() => flash.classList.remove('active'), 300);
        }

        function drawWaveform(umwelt, dataArray) {
            const canvas = document.getElementById(`waveform${umwelt}`);
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);
            
            ctx.lineWidth = 2;
            ctx.strokeStyle = umwelt === 'A' ? '#667eea' : '#764ba2';
            ctx.beginPath();
            
            const sliceWidth = width / dataArray.length;
            let x = 0;
            
            for (let i = 0; i < dataArray.length; i++) {
                const v = dataArray[i] / 128.0;
                const y = v * height / 2;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
                
                x += sliceWidth;
            }
            
            ctx.stroke();
        }

        function animate() {
            if (!isRunning) return;
            
            analyzeAudio();
            requestAnimationFrame(animate);
        }

        function stopAudio() {
            isRunning = false;
            
            // Stop microphone streams
            const msA = micStreamA;
            if (msA) {
                msA.getTracks().forEach(track => track.stop());
                micStreamA = null;
            }
            if (micStreamB && micStreamB !== msA) {
                micStreamB.getTracks().forEach(track => track.stop());
                micStreamB = null;
            }
            
            if (audioContext) {
                audioContext.close();
                audioContext = null;
                channelSplitter = null;
                micFilterA = null;
                micGainA = null;
                micFilterB = null;
                micGainB = null;
            }
            outputNodes.forEach(node => {
                try {
                    masterGain.disconnect(node);
                    fxGain.disconnect(node);
                    node.disconnect();
                } catch (e) {}
            });
            outputNodes = [];
            outputAudios.forEach(el => el.remove());
            outputAudios = [];

            
            // Reset detectors
            detectorA.reset();
            detectorB.reset();
            
            // Reset UI
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('testA').disabled = true;
            document.getElementById('testB').disabled = true;
            
            updateStatus('Audio system stopped', 'success');
        }

        function updateStatus(message, type = '') {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = 'status-message ' + type;
            
            if (type) {
                setTimeout(() => {
                    statusEl.className = 'status-message';
                    statusEl.textContent = '';
                }, 3000);
            }
        }

        // Simulate heartbeat peaks for testing
        function simulatePeakA() {
            if (!sourceA || !isTestMode) return;
            sourceA.gain.setValueAtTime(1, audioContext.currentTime);
            sourceA.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.1);
        }

        function simulatePeakB() {
            if (!sourceB || !isTestMode) return;
            sourceB.gain.setValueAtTime(1, audioContext.currentTime);
            sourceB.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.1);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', initAudio);
        document.getElementById('stopBtn').addEventListener('click', stopAudio);
        document.getElementById('testA').addEventListener('click', simulatePeakA);
        document.getElementById('testB').addEventListener('click', simulatePeakB);
        document.getElementById('micMonitorToggle').addEventListener('change', e => {
            micMonitorEnabled = e.target.checked;
            if (micGainA) micGainA.gain.value = micMonitorEnabled ? dBToAmp(params.MIC_MONITOR_GAIN_DB) : 0;
            if (micGainB) micGainB.gain.value = micMonitorEnabled ? dBToAmp(params.MIC_MONITOR_GAIN_DB) : 0;
        });

        // Parameter controls
        document.getElementById('lowpassFreq').addEventListener('input', (e) => {
            params.INPUT_LOWPASS_FREQ = parseInt(e.target.value);
            document.getElementById('lowpassFreqValue').textContent = e.target.value + ' Hz';
            if (filterA) filterA.frequency.value = params.INPUT_LOWPASS_FREQ;
            if (filterB) filterB.frequency.value = params.INPUT_LOWPASS_FREQ;
        });

        document.getElementById('peakThreshold').addEventListener('input', (e) => {
            params.PEAK_THRESHOLD = parseFloat(e.target.value);
            document.getElementById('peakThresholdValue').textContent = e.target.value;
            detectorA.threshold = params.PEAK_THRESHOLD;
            detectorB.threshold = params.PEAK_THRESHOLD;
        });

        document.getElementById('micMonitorGain').addEventListener('input', (e) => {
            params.MIC_MONITOR_GAIN_DB = parseFloat(e.target.value);
            document.getElementById('micMonitorGainValue').textContent = e.target.value + ' dB';
            if (micGainA) micGainA.gain.value = micMonitorEnabled ? dBToAmp(params.MIC_MONITOR_GAIN_DB) : 0;
            if (micGainB) micGainB.gain.value = micMonitorEnabled ? dBToAmp(params.MIC_MONITOR_GAIN_DB) : 0;
        });

        document.getElementById('micFilterFreq').addEventListener('input', (e) => {
            params.MIC_FILTER_FREQ = parseInt(e.target.value);
            document.getElementById('micFilterFreqValue').textContent = e.target.value + ' Hz';
            if (micFilterA) micFilterA.frequency.value = params.MIC_FILTER_FREQ;
            if (micFilterB) micFilterB.frequency.value = params.MIC_FILTER_FREQ;
        });

        document.getElementById('triggerAFreq').addEventListener('input', (e) => {
            params.TRIGGER_A_FREQ = parseInt(e.target.value);
            document.getElementById('triggerAFreqValue').textContent = e.target.value + ' Hz';
        });

        document.getElementById('droneAFreq').addEventListener('input', (e) => {
            params.DRONE_A_BASE_FREQ = parseInt(e.target.value);
            document.getElementById('droneAFreqValue').textContent = e.target.value + ' Hz';
            if (droneOscA) droneOscA.frequency.value = params.DRONE_A_BASE_FREQ;
        });

        document.getElementById('droneBFreq').addEventListener('input', (e) => {
            params.DRONE_B_BASE_FREQ = parseInt(e.target.value);
            document.getElementById('droneBFreqValue').textContent = e.target.value + ' Hz';
            if (droneOscB) droneOscB.frequency.value = params.DRONE_B_BASE_FREQ;
        });

        document.getElementById('delayBase').addEventListener('input', (e) => {
            params.KNOT_DELAY_BASE_TIME = parseFloat(e.target.value);
            document.getElementById('delayBaseValue').textContent = e.target.value + ' s';
        });

        document.getElementById('modAmount').addEventListener('input', (e) => {
            params.KNOT_DELAY_MOD_AMOUNT = parseFloat(e.target.value);
            document.getElementById('modAmountValue').textContent = e.target.value + ' s';
        });

        document.getElementById('feedback').addEventListener('input', (e) => {
            params.KNOT_DELAY_FEEDBACK = parseFloat(e.target.value);
            document.getElementById('feedbackValue').textContent = e.target.value;
            if (feedbackGainA) feedbackGainA.gain.value = params.KNOT_DELAY_FEEDBACK;
            if (feedbackGainB) feedbackGainB.gain.value = params.KNOT_DELAY_FEEDBACK;
        });

        document.getElementById('preKnotGain').addEventListener('input', (e) => {
            params.PRE_KNOT_GAIN = parseFloat(e.target.value);
            document.getElementById('preKnotGainValue').textContent = e.target.value;
            if (masterGain) masterGain.gain.value = params.PRE_KNOT_GAIN;
        });

        document.getElementById('knotFxGain').addEventListener('input', (e) => {
            params.KNOT_FX_GAIN = parseFloat(e.target.value);
            document.getElementById('knotFxGainValue').textContent = e.target.value;
            if (fxGain) fxGain.gain.value = params.KNOT_FX_GAIN;
        });

        // Initialize canvas sizes
        function resizeCanvases() {
            const canvases = ['waveformA', 'waveformB'];
            canvases.forEach(id => {
                const canvas = document.getElementById(id);
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
            });
        }

        window.addEventListener('resize', resizeCanvases);
        resizeCanvases();

        populateDeviceSelectors();

        // Display initial status
        updateStatus('Click "Start Audio" to begin the experience');
    </script>
</body>
</html>
